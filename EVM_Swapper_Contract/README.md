
# Swapper Contract

The **Swapper** contract is a UUPS upgradeable smart contract designed for token swaps using an external aggregator ( 0x). The contract supports both ERC20 tokens and native tokens, allowing seamless token swaps while charging a configurable fee that is sent to the admin address.

---

## Contract Flow

### Overview
1. **User initiates a swap:**
   - Calls the `swap` function with encoded data and the source token.

2. **Calldata Generation is Done with ZKCross API**
   - 0X Calldata is wrapped over another wrapping based on the SwapDescription Struct.
   - Wrapped calldata is used in the swaping of token
   - API used to get calldata https://api.zkcross.network/api/v1/bridge/swap params are sellToken, buyToken, sellAmount, chainId.

2. **Contract processes the swap:**
   - Decodes the provided wrapped call data from API.
   - Transfers the required tokens from the user to the contract (for ERC20 tokens).
   - Approves the external aggregator to spend the tokens if necessary.
   - Executes the swap through the external aggregator (e.g., 0x API).

3. **Fee deduction:**
   - The contract calculates a fee based on the `swapFeePercentage` and transfers it to the `swapAdmin` address.

4. **Swap output handling:**
   - The remaining swapped tokens (post-fee deduction) are sent back to the user.

---

## Test case
1. Written hardhat test file to test the contract with all the sinarios of call data attack. 
2. With any arbitrary calldata is not executed as it has to follow the paraten of decode and must be compatible and correct with the 0x calldata.
3. Since there is no fund will be left in contract so no chance of fund loss. 
4. So any one can call the swap function provided with the valid calldata 

## Features
1. **UUPS Upgradeable:** The contract supports upgrades using OpenZeppelin's UUPS pattern.
2. **Configurable Admin and Fee:** 
   - Admin can update the swap fee percentage.
   - Swap fees are sent directly to the admin wallet.

3. **ERC20 and Native Token Support:** Supports swaps with both ERC20 tokens and native chain tokens.

4. **Security Mechanisms:**
   - Pausable: The contract can be paused by the owner to halt operations.
   - Non-reentrancy: Prevents reentrancy attacks.

5. **Aggregator Integration:**
   - Uses `newExchange` to interact with an external aggregator (e.g., 0x) for executing swaps.

---

## Setup

### Deployment
The contract accepts the `swapAdmin` address as an initializer parameter.

```javascript
const Swapper = await ethers.getContractFactory("Swapper");
const swapper = await upgrades.deployProxy(Swapper, [swapAdmin], { initializer: "initialize" });
```

### Configuration
- **Setting the Swap Fee Percentage:**
  The owner can set the fee percentage using the `updateSwapFee` function:
  ```javascript
  await swapper.updateSwapFee(50); // Sets the fee to 0.5% (50 basis points)
  ```
- **Updating the External Aggregator Address:**
  The owner can update the aggregator address (e.g., 0x Exchange Proxy) using `setNewExchange`:
  ```javascript
  await swapper.setNewExchange("0xDef1C0ded9bec7F1a1670819833240f027b25EfF");
  ```

---

## Using the Contract

### Input Format
The `swap` function accepts two parameters:
1. `_data`: Encoded swap details (wrapped data).
2. `_swapper`: Address of the user performing the swap.

#### Wrapped Data Decoding
The `_data` parameter contains:
- `srcToken`: Address of the source token.
- `dstToken`: Address of the destination token.
- `amount`: Amount of the source token to swap.
- `data`: Encoded call data generated by the external aggregator (e.g., 0x API).

**How the `decode` function works:**
The `decode` function unpacks the wrapped call data:
```solidity
function _decode(bytes calldata _data)
    private
    pure
    returns (SwapDescription memory)
{
    (address srcToken, address dstToken, uint256 amount, bytes memory data) = abi.decode(
        _data,
        (address, address, uint256, bytes)
    );
    return SwapDescription(srcToken, dstToken, amount, data);
}
```
- The outer wrapper provides high-level details (e.g., source and destination tokens).
- The `data` field contains further encoded details required by the external aggregator for executing the swap.

---

## Encoding Call Data

### How to Encode Call Data for 0x Aggregator
1. **Generate the Raw Call Data:** Use the 0x API to fetch the swap details and call data for the desired swap.
2. **Wrap the Call Data:** Construct the wrapped data structure containing:
   - `srcToken`: Address of the token you want to swap.
   - `dstToken`: Address of the token you want to receive.
   - `amount`: Amount of `srcToken` to swap.
   - `data`: The raw call data from the 0x API.

3. **Encode Using `abi.encode`:**
   ```javascript
   const wrappedData = ethers.utils.defaultAbiCoder.encode(
       ["address", "address", "uint256", "bytes"],
       [srcToken, dstToken, amount, rawCallData]
   );
   ```

4. **Call the Swap Function:** Pass the encoded data to the `swap` function:
   ```javascript
   await swapper.swap(wrappedData, userAddress, { value: nativeTokenAmount });
   ```

---

## Key Considerations

### Aggregator Address
- The `newExchange` variable must point to a supported aggregator (e.g., 0x Exchange Proxy at `0xDef1C0ded9bec7F1a1670819833240f027b25EfF`).
- The aggregator handles the actual swap by interacting with various liquidity sources.

### Fee Deduction
The contract deducts a fee (based on `swapFeePercentage`) from the swap output before transferring the remaining tokens to the user. The fee is sent directly to the admin (`swapAdmin`).

---

## Example Scenarios

### Native Token Swap
- Input: Swap `ETH` for `DAI`.
- Wrapped Data: Encodes `srcToken` as `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, `dstToken` as `DAI` address, and 0x call data.
- Result: Receives `DAI` after deducting the fee.

### ERC20 Token Swap
- Input: Swap `USDT` for `WBTC`.
- Wrapped Data: Encodes `srcToken` as `USDT` address, `dstToken` as `WBTC` address, and 0x call data.
- Result: Receives `WBTC` after deducting the fee.

---

## Events

### Swapped Event
Emitted after a successful swap:
```solidity
event Swapped(
    address indexed user,
    address indexed inputToken,
    address indexed outputToken,
    uint256 inputAmount,
    uint256 outputAmount,
    uint256 fee
);
```

### Admin-Related Events
- `AdminAdded`: Logs when an admin is added.
- `SwapFeeUpdated`: Logs when the swap fee percentage is updated.

---
# Usage of  Hardhat Project

This project demonstrates a basic Hardhat use case. It comes with a sample contract, a test for that contract, and a Hardhat Ignition module that deploys that contract.

Try running some of the following tasks:

```shell
npx hardhat help
npx hardhat test
REPORT_GAS=true npx hardhat test

npx hardhat run ignition deploy ./ignition/modules/deploy.js --network sepolia
```

## Test to be performed in Speolia Network 
# User Must have Link token and Sepolia ETH to perform test

```
npx hardhat test test/swapper.test.js --network sepolia

```


---

This **Swapper Contract** provides a modular and secure solution for handling token swaps with an external aggregator like 0x. It is designed with user flexibility and admin control in mind while ensuring seamless integration with token protocols.
